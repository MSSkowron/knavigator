/*
 * Copyright (c) 2024, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package utils

import (
	"bytes"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"text/template"
)

var rangeRegex *regexp.Regexp

func init() {
	rangeRegex = regexp.MustCompile(`^(\d+)-(\d+)$|^(\d+)$`)
}

// NameList represents a list of names, where :
//   - "Patterns" is an array of name templates,
//   - "Params" is a key-value map of parameters for the templates.
type NameList struct {
	Patterns []string               `yaml:"patterns"`
	Params   map[string]interface{} `yaml:"params,omitempty"`
}

// NameRange represents a range of names, where :
//   - "Pattern" is a name template. The reserved variable _INDEX_ represents a number from the range.
//   - "Ranges" is an array os values formatted as 'm-n' or 'n'.
//     Each range 'm-n' denotes a sequence from 'm' to 'n', inclusive.
//   - "Params" is a key-value map of parameters for the template.
type NameRange struct {
	Pattern string                 `yaml:"pattern"`
	Ranges  []string               `yaml:"ranges"`
	Params  map[string]interface{} `yaml:"params,omitempty"`
}

// NameSelector represents an object for generating and matching a set of names
type NameSelector struct {
	List   *NameList  `yaml:"list,omitempty"`
	Range  *NameRange `yaml:"range,omitempty"`
	Regexp string     `yaml:"regexp,omitempty"`

	// derived
	names  []string
	regexp *regexp.Regexp
}

func (ns *NameSelector) Init() {
	ns.names = []string{}
}

// Finalize validates and finalizes instantiation of NameSelector
func (ns *NameSelector) Finalize() error {
	if list := ns.List; list != nil {
		if len(list.Patterns) == 0 {
			return fmt.Errorf("missing patterns in name list")
		}
		for _, pattern := range list.Patterns {
			tpl, err := template.New("name").Parse(pattern)
			if err != nil {
				return fmt.Errorf("failed to parse template %s: %v", pattern, err)
			}
			if err = ns.addName(tpl, pattern, list.Params); err != nil {
				return err
			}
		}
	}

	if r := ns.Range; r != nil {
		if len(r.Pattern) == 0 {
			return fmt.Errorf("missing pattern in name range")
		}
		if len(r.Ranges) == 0 {
			return fmt.Errorf("missing ranges in name range")
		}
		if r.Params == nil {
			r.Params = make(map[string]interface{})
		}
		tpl, err := template.New("name").Parse(r.Pattern)
		if err != nil {
			return fmt.Errorf("failed to parse template %s: %v", r.Pattern, err)
		}
		for _, rng := range r.Ranges {
			matches := rangeRegex.FindAllStringSubmatch(strings.TrimSpace(rng), -1)
			if len(matches) != 1 {
				return fmt.Errorf("invalid range %q in name range", rng)
			}
			match := matches[0]
			if len(match) != 4 {
				return fmt.Errorf("invalid range %q in name range", rng)
			}
			if match[1] != "" && match[2] != "" { // from-to range
				start, err := strconv.Atoi(match[1])
				if err != nil {
					return fmt.Errorf("invalid range %q in name range: %v", rng, err)
				}
				end, err := strconv.Atoi(match[2])
				if err != nil {
					return fmt.Errorf("invalid range %q in name range: %v", rng, err)
				}
				if start > end {
					return fmt.Errorf("invalid range %q in name range", rng)
				}
				for indx := start; indx <= end; indx++ {
					r.Params["_INDEX_"] = indx
					if err = ns.addName(tpl, r.Pattern, r.Params); err != nil {
						return err
					}
				}
			} else if match[3] != "" { // single value range
				indx, err := strconv.Atoi(match[3])
				if err != nil {
					return fmt.Errorf("invalid range %q in name range: %v", rng, err)
				}
				r.Params["_INDEX_"] = indx
				if err = ns.addName(tpl, r.Pattern, r.Params); err != nil {
					return err
				}
			}
		}
	}

	if len(ns.Regexp) != 0 {
		var err error
		if ns.regexp, err = regexp.Compile(ns.Regexp); err != nil {
			return err
		}
	}

	return nil
}

func (ns *NameSelector) addName(tpl *template.Template, pattern string, params map[string]interface{}) error {
	buf := new(bytes.Buffer)
	if err := tpl.Execute(buf, params); err != nil {
		return fmt.Errorf("failed to execute template %s: %v", pattern, err)
	}
	ns.names = append(ns.names, buf.String())
	return nil
}

func (ns *NameSelector) Names() []string {
	return ns.names
}

// NameSelector represents an object for iterating over names generated by NameSelector
type NameIterator struct {
	names []string
	index int
}

func (ns *NameSelector) Iter() *NameIterator {
	return &NameIterator{names: ns.names}
}

func (iter *NameIterator) HasNext() bool {
	return iter.index < len(iter.names)
}

func (iter *NameIterator) GetNext() string {
	defer func() { iter.index++ }()
	return iter.names[iter.index]
}

// NameMatcher represents an object for matching names represented by NameSelector
type NameMatcher struct {
	names  map[string]bool
	regexp *regexp.Regexp
}

func (ns *NameSelector) Matcher() *NameMatcher {
	m := &NameMatcher{
		names:  make(map[string]bool),
		regexp: ns.regexp,
	}

	for _, name := range ns.names {
		m.names[name] = true
	}

	return m
}

func (nm *NameMatcher) IsMatch(name string) bool {
	return nm.names[name] || (nm.regexp != nil && nm.regexp.MatchString(name))
}
